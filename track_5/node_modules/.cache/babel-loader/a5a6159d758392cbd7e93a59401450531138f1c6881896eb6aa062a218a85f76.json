{"ast":null,"code":"// Utility functions for formatting data in the Doma Protocol application\n\n/**\n * Format Ether values from wei to readable format\n */\nexport function formatEther(wei) {\n  try {\n    const value = typeof wei === 'string' ? BigInt(wei) : wei;\n    const ether = Number(value) / Math.pow(10, 18);\n    if (ether === 0) return '0';\n    if (ether < 0.0001) return '<0.0001';\n    if (ether < 1) return ether.toFixed(4);\n    if (ether < 1000) return ether.toFixed(2);\n    return ether.toLocaleString('en-US', {\n      maximumFractionDigits: 2,\n      minimumFractionDigits: 0\n    });\n  } catch (error) {\n    console.error('Error formatting ether:', error);\n    return '0';\n  }\n}\n\n/**\n * Format price with currency symbol\n */\nexport function formatPrice(price, currency = 'ETH') {\n  try {\n    const numPrice = typeof price === 'string' ? parseFloat(price) : price;\n    if (isNaN(numPrice)) return `0 ${currency}`;\n    if (numPrice === 0) return `0 ${currency}`;\n    if (numPrice < 0.0001) return `<0.0001 ${currency}`;\n    return `${formatEther(BigInt(Math.floor(numPrice * Math.pow(10, 18))))} ${currency}`;\n  } catch (error) {\n    console.error('Error formatting price:', error);\n    return `0 ${currency}`;\n  }\n}\n\n/**\n * Format Ethereum address for display\n */\nexport function formatAddress(address, length = 6) {\n  if (!address || address.length < 10) return address;\n  const start = address.slice(0, length);\n  const end = address.slice(-4);\n  return `${start}...${end}`;\n}\n\n/**\n * Format time ago from timestamp\n */\nexport function formatTimeAgo(timestamp) {\n  try {\n    const date = typeof timestamp === 'string' ? new Date(timestamp) : new Date(timestamp * 1000);\n    const now = new Date();\n    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);\n    if (diffInSeconds < 60) return 'Just now';\n    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;\n    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;\n    if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;\n    return date.toLocaleDateString();\n  } catch (error) {\n    console.error('Error formatting time ago:', error);\n    return 'Unknown';\n  }\n}\n\n/**\n * Get domain category based on name characteristics\n */\nexport function getDomainCategory(name) {\n  if (!name) return 'unknown';\n  if (name.length <= 3) return 'premium';\n  if (name.length === 4) return 'short';\n  if (/^\\d+$/.test(name)) return 'numeric';\n  if (/^[a-z]+$/.test(name)) return 'alphabetic';\n  if (/\\d/.test(name) && /[a-z]/.test(name)) return 'alphanumeric';\n  return 'standard';\n}\n\n/**\n * Check if domain is expired\n */\nexport function isExpired(expirationDate) {\n  try {\n    const expiry = typeof expirationDate === 'string' ? new Date(expirationDate) : new Date(expirationDate * 1000);\n    return expiry.getTime() < Date.now();\n  } catch (error) {\n    console.error('Error checking expiration:', error);\n    return false;\n  }\n}\n\n/**\n * Calculate time remaining until expiration\n */\nexport function getTimeRemaining(expirationDate) {\n  try {\n    const expiry = typeof expirationDate === 'string' ? new Date(expirationDate) : new Date(expirationDate * 1000);\n    const now = new Date();\n    const diffInMs = expiry.getTime() - now.getTime();\n    if (diffInMs <= 0) return 'Expired';\n    const days = Math.floor(diffInMs / (1000 * 60 * 60 * 24));\n    const hours = Math.floor(diffInMs % (1000 * 60 * 60 * 24) / (1000 * 60 * 60));\n    if (days > 30) return `${Math.floor(days / 30)} months`;\n    if (days > 0) return `${days} days`;\n    if (hours > 0) return `${hours} hours`;\n    return 'Less than 1 hour';\n  } catch (error) {\n    console.error('Error calculating time remaining:', error);\n    return 'Unknown';\n  }\n}","map":{"version":3,"names":["formatEther","wei","value","BigInt","ether","Number","Math","pow","toFixed","toLocaleString","maximumFractionDigits","minimumFractionDigits","error","console","formatPrice","price","currency","numPrice","parseFloat","isNaN","floor","formatAddress","address","length","start","slice","end","formatTimeAgo","timestamp","date","Date","now","diffInSeconds","getTime","toLocaleDateString","getDomainCategory","name","test","isExpired","expirationDate","expiry","getTimeRemaining","diffInMs","days","hours"],"sources":["/Users/kaelabbott/Downloads/autozama/doma/src/utils/formatters.ts"],"sourcesContent":["// Utility functions for formatting data in the Doma Protocol application\n\n/**\n * Format Ether values from wei to readable format\n */\nexport function formatEther(wei: string | bigint): string {\n  try {\n    const value = typeof wei === 'string' ? BigInt(wei) : wei;\n    const ether = Number(value) / Math.pow(10, 18);\n    \n    if (ether === 0) return '0';\n    if (ether < 0.0001) return '<0.0001';\n    if (ether < 1) return ether.toFixed(4);\n    if (ether < 1000) return ether.toFixed(2);\n    \n    return ether.toLocaleString('en-US', { \n      maximumFractionDigits: 2,\n      minimumFractionDigits: 0 \n    });\n  } catch (error) {\n    console.error('Error formatting ether:', error);\n    return '0';\n  }\n}\n\n/**\n * Format price with currency symbol\n */\nexport function formatPrice(price: string | number, currency: string = 'ETH'): string {\n  try {\n    const numPrice = typeof price === 'string' ? parseFloat(price) : price;\n    if (isNaN(numPrice)) return `0 ${currency}`;\n    \n    if (numPrice === 0) return `0 ${currency}`;\n    if (numPrice < 0.0001) return `<0.0001 ${currency}`;\n    \n    return `${formatEther(BigInt(Math.floor(numPrice * Math.pow(10, 18))))} ${currency}`;\n  } catch (error) {\n    console.error('Error formatting price:', error);\n    return `0 ${currency}`;\n  }\n}\n\n/**\n * Format Ethereum address for display\n */\nexport function formatAddress(address: string, length: number = 6): string {\n  if (!address || address.length < 10) return address;\n  \n  const start = address.slice(0, length);\n  const end = address.slice(-4);\n  return `${start}...${end}`;\n}\n\n/**\n * Format time ago from timestamp\n */\nexport function formatTimeAgo(timestamp: number | string): string {\n  try {\n    const date = typeof timestamp === 'string' ? new Date(timestamp) : new Date(timestamp * 1000);\n    const now = new Date();\n    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);\n    \n    if (diffInSeconds < 60) return 'Just now';\n    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;\n    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;\n    if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;\n    \n    return date.toLocaleDateString();\n  } catch (error) {\n    console.error('Error formatting time ago:', error);\n    return 'Unknown';\n  }\n}\n\n/**\n * Get domain category based on name characteristics\n */\nexport function getDomainCategory(name: string): string {\n  if (!name) return 'unknown';\n  \n  if (name.length <= 3) return 'premium';\n  if (name.length === 4) return 'short';\n  if (/^\\d+$/.test(name)) return 'numeric';\n  if (/^[a-z]+$/.test(name)) return 'alphabetic';\n  if (/\\d/.test(name) && /[a-z]/.test(name)) return 'alphanumeric';\n  \n  return 'standard';\n}\n\n/**\n * Check if domain is expired\n */\nexport function isExpired(expirationDate: string | number): boolean {\n  try {\n    const expiry = typeof expirationDate === 'string' \n      ? new Date(expirationDate) \n      : new Date(expirationDate * 1000);\n    \n    return expiry.getTime() < Date.now();\n  } catch (error) {\n    console.error('Error checking expiration:', error);\n    return false;\n  }\n}\n\n/**\n * Calculate time remaining until expiration\n */\nexport function getTimeRemaining(expirationDate: string | number): string {\n  try {\n    const expiry = typeof expirationDate === 'string' \n      ? new Date(expirationDate) \n      : new Date(expirationDate * 1000);\n    \n    const now = new Date();\n    const diffInMs = expiry.getTime() - now.getTime();\n    \n    if (diffInMs <= 0) return 'Expired';\n    \n    const days = Math.floor(diffInMs / (1000 * 60 * 60 * 24));\n    const hours = Math.floor((diffInMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));\n    \n    if (days > 30) return `${Math.floor(days / 30)} months`;\n    if (days > 0) return `${days} days`;\n    if (hours > 0) return `${hours} hours`;\n    \n    return 'Less than 1 hour';\n  } catch (error) {\n    console.error('Error calculating time remaining:', error);\n    return 'Unknown';\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}